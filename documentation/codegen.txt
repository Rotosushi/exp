// Copyright (C) 2024 Cade Weinberg
// 
// This file is part of exp.
// 
// exp is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// exp is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with exp.  If not, see <http://www.gnu.org/licenses/>.


"how does the backend generate target machine assembly?"

[https://arxiv.org/abs/1306.4898]

there are three main tasks which need to be accomplished:
    - instruction selection 
    - instruction scheduling 
    - register allocation 

these three tasks are tightly coupled in the sense that 
which instruction is selected has influence over which 
register a value needs to be allocated within.
And the reverse is true, which register a value is allocated 
in has influence over which instructions can be selected.
and this is occuring on a time axis as well, because
values will often be needed within expressions that occur 
later within the same scope, which affects where you can 
schedule the instructions.

this is all on top of the fact that specific instructions have 
further constraints on what registers their inputs can be in,
what registers they affect as outputs, and how long each
instruction takes to execute.

the main thread that I have picked up is:
data-flow analysis plus control-flow-analysis.

We are implementing a block-structured language.

this means that for each instruction (I) within a basic block (BB) 
the flow of execution starts at the top, and ends at the bottom.
if there is some number (n) of I within a BB we can be sure 
Iâ‚™ execute when we execute that BB. 

there are two kinds of breaks in this control flow, conditions and loops.

within a condition, there is a choice of BB to execute.

within a loop there is repeated execution of the same BB.

and, these three constructs can be recursively applied.

so we can have a basic block which contains a loop, and that 
loop can contain a condition, and one of the choices can contain 
another loop. Or any other possible combination of the above, ad-infinitum.

we essentially have three patterns

1 -> <BB> ->

2 -> C
    -> <BB0> 
    -> <BB1> 
  ->

3 -> Loop
    -> <BB0> -> Loop
    ->
 
if we consider the lowercase letters to be basic blocks with no 
internal basic blocks. (we could call them simple, or straight-line, 
or linear, or terminal, or case 1)

then we consider the upper-case letters to be basic blocks with 
some number of internal basic blocks. (we could call them composite,
or complex, or non-terminal, or case 2/3)

then modulo instructions and block structured program could be expressed
as a graph of composed of these basic blocks.

for instance we could have 

-> <A> -> 

<A> -> C
        -> <B> 
        -> <C>
    -> <D>

<B> -> L 
        -> a -> L
        -> 

<C> -> b ->

<D> -> c -> 

if the assembly instructions which implement conditions and loops 
are correctly modeled by this, and if we take the main subroutine
to be the first basic block of a given program. 
then I think this could be said to be the control flow graph of the program.

we still need to model each instruction and sequence of instructions which 
make up the semantics of individual language constructs. starting with binary and 
unary operations on local variables. which we are starting with arithmetic.
each bytecode instruction takes inputs and produces an output.
and instruction can use existing locals as inputs, and we can think of the 
flow of data through these instructions as the data-flow graph. 

and this isn't the whole story about bytecode instructions, we also need the 
data-flow graph to include information about the phi instructions which are 
used to handle the multiple incoming edges to certain variables when those 
variables have values which could come from multiple sources.
for instance a variable is modified by both arms of an if-else conditional,
and is used later in it's lifetime. How do we know which initializer to choose
when the choice is happening at runtime? This is what the phi node models.

then each target machine instruction has it's own set of inputs and outputs,
has a time which it takes to run, has a place in the processor in which it runs, 
which means that we can form a data-flow graph for a set of assembly instructions 
as well. with additional information such as the costs and constraints of that 
instruction.


Thus we have multiple graphs worth of important information all of which are 
important in making choices about which instructions to select, where to 
place them, and what registers are they operate on.

So, the method that I want to apply is pattern-matching and pattern-selection.

The basic idea is (afaict) to model the underlying x64 ISA as a set of 
a little pieces of a graph. a set of patterns.

then we take the total input graph which models the bytecode, and we construct 
a new graph out of patterns which implement the input graph.






