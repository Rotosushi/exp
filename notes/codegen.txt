// Copyright (C) 2024 Cade Weinberg
// 
// This file is part of exp.
// 
// exp is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// exp is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with exp.  If not, see <http://www.gnu.org/licenses/>.


"how does the backend generate target machine assembly?"

[https://arxiv.org/abs/1306.4898]

there are three main tasks which need to be accomplished:
    - instruction selection 
    - instruction scheduling 
    - register allocation 

these three tasks are tightly coupled in the sense that 
which instruction is selected has influence over which 
register a value needs to be allocated within.
And the reverse is true, which register a value is allocated 
in has influence over which instructions can be selected.
and this is occuring on a time axis as well, because
values will often be needed within expressions that occur 
later within the same scope, which affects where you can 
schedule the instructions.

this is all on top of the fact that specific instructions have 
further constraints on what registers their inputs can be in,
what registers they affect as outputs, and how long each
instruction takes to execute.

a classic approach is using a table driven LR(1) parser which 
is generated by a specification of the ISA specified in EBNF.

We are using an even older approach which could be called "direct replacement"
or "macro-style" where each given bytecode instruction is directly encoded 
into x64 instructions one after another. This means the code generated is not 
optimized. It isn't directly pessimized either, it's just that since there is no 
consideration of the time-axis sub-optimal code can be produced depending upon 
the ordering of the source code.












