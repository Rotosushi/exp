
Questions related to how efficiently we compile code.

How much are we allocating to compile a given file?

How large are the most commonly used kinds of data?

(#NOTE language feature idea: extend what is available with 
    the lsp essentially. 
    Add on a depiction of the call graph,
    the size and layout of each struct, 
    and other kinds of language statistics. 
    on a live update of the disassembly.
    a visualization of the heap, and stack.
    this would probably require running in something akin to 
    a debugger. 
    wait, I am describing an integrated development environment.
    except, maybe not, I am just describing getting that information out 
    of the compiler. does the compiler need to be made aware of how to 
    render things to the screen? it seems like there is a natural place 
    for the compiler to act as a sort of library of an integrated development 
    environment.
    what is the compiler in a position to compute?
    what kinds of query can you make using the knowledge base of the compiler?

    list fan-in
         fan-out
         disassembly
         source-lines-of-code
         source-lines-of-disassembly

    can we have a repl using compiled code?


    what could the workflow using the repl look like?
    \repl-workflow:
        - load up existing codebase
        - while(!errors)
            - make an update
            - debug update
        - write out updated codebase

    \language-server
        - start server
        - connect with a repl
        - repl-workflow
        - disconnect the repl
        - end server

    we can dynamically patch in code if the assembly for the 
    code calls through a global function pointer, as long as the 
    signature of the function does not change, we don't have 
    to recompile any assembly which relies on that call point.
    we can use the dynamic loader to link in a new function definition,
    and then update a global function pointer with the address of the 
    new function definition.

    if the signature does change, then we can enumerate each place in the
    program which needs updating, in a repl environment we can present
    them to the developer right then.
    after all changes have been made we can recompile all of the functions
    which were modified to fix the last modification, and simply update
    all of their function pointers.

    This, in a loop, can be the repl.

    there would need to be a command for goto definition, which you could enter 
    in the repl, this would take you a state where you could edit the definition.

    wait a second, text editing?
    yeah, you have to edit the definition of a function to make a change,
    so of course, you have to edit text.
    why not work in a text editor?
    well, okay, so instead of a line-by-line repl we have a text editor?
    why not make each line as if it were in a repl?

    oh, so we just evaluate each line as it is entered, and display the
    result on the next line?
    sure, as long as the displayed result isn't actually entering text
    into the source-code, yeah.
    
    okay, so its like a source file, opened in a text editor, except 
    this piece of text is treated as a live-updating executable/library
    which can be interacted with in the language of the source file?

    yes, I think that is what I am describing.
    and you have to be able to import other source files, and have that 
    both bring in those definitions, (just like how you expect), and be 
    able to switch to viewing the other source file, and be able to update 
    it and live see the difference.

    and live view the current statistics of the program. 
    and live debug and step through this interactive version 
    of the program you are writing.

    can we live-update and debug at the same time?
    well, if you can live with load times, yes.
    and if you can live with not necessarily being 
    brought to the same place when you debug, make a change,
    and reenter debug mode.

    oh, oh hey.

    vim modes: defualt (command), insert, visual, and the others.

    iteractivity modes: default (repl), insert, visual, multiline-edit, debug, statistics, symbol-renaming,
    you know, I think I am describing an IDE, it's just, adding on the part where you can load up a project 
    and make edits and see the results of the changes you make right away, just, as soon as possible.
    like, it would in fact be cool if you could pause debugging, make an edit to the code that just failed,
    and pick up right where you left off before the failure point.

    if the failure point involves removing all of the code that you were just debugging?

    well, how about just being able to restart debugging from the new executable right after making the change.
    like, 
    - enter insert mode
    - edit text
    - enter debug mode
    - debug
    - enter insert mode 
    - edit text 
    - enter debug mode

    modulo the individual commands. The seamless transition between insert and debug modes
    while editing the file itself is the thing that the server allows. because the session
    that is editing text is the same session that is the debugger, which is the same
    session that is the build system, which is the same system that is the source code manager,

    


)





