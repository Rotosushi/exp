/**
 * Copyright (C) 2024 Cade Weinberg
 *
 * This file is part of exp.
 *
 * exp is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * exp is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with exp.  If not, see <https://www.gnu.org/licenses/>.
 */
#include <stddef.h>
#include <stdlib.h>

#include "backend/compute_allocations.h"

/*
  in order to test allocations we have to have some expected
  allocations from a known set of lifetimes, and then compare
  that to the allocations computed from that set of lifetimes.

  it would be nice to automatically generate a set of Lifetimes
  along with the set of allocations which would be generated by
  following the linear scan register allocation algorithm,
  but isn't such an auto-gen function equivalent to the LSRA?
  or at least as complex as the LSRA? and so would need testing
  itself to ensure it was correct?
*/

static Lifetime lifetime(u16 l, u16 fu, u16 lu) {
  Lifetime r = {.local = l, .first_use = fu, .last_use = lu};
  return r;
}

Lifetimes test_lifetimes() {
  // {%0, 0, 2}, {%1, 1, 2}, {%2, 2, 3}
  Lifetimes test = lifetimes_create();
  lifetimes_insert_sorted(&test, lifetime(0, 0, 2));
  lifetimes_insert_sorted(&test, lifetime(1, 1, 2));
  lifetimes_insert_sorted(&test, lifetime(2, 2, 3));
  return test;
}

Allocations expected_allocations() {
  // since we allocate registers by chosing the
  // first available, we expect
  // {%0, ALLOC_REG, REG_RAX},
  // {%1, ALLOC_REG, REG_RBX},
  // {%2, ALLOC_REG, REG_RCX}
  Allocations expected = allocations_create();
  allocations_allocate(&expected, 0, REG_RAX);
  allocations_allocate(&expected, 1, REG_RBX);
  allocations_allocate(&expected, 2, REG_RCX);
  return expected;
}

static bool allocation_matches(Allocation e, Allocation a) {
  if (e.local != a.local) {
    return 0;
  }

  if (e.kind != a.kind) {
    return 0;
  }

  switch (e.kind) {
  case ALLOC_REG:
    return e.reg == a.reg;

  case ALLOC_STACK:
    return e.offset == a.offset;

  default:
    unreachable();
  }
}

static bool allocations_match(Allocations *restrict expected,
                              Allocations *restrict actual) {
  if (expected->size != actual->size) {
    return 0;
  }

  if (expected->stack_size != actual->stack_size) {
    return 0;
  }

  for (u16 i = 0; i < expected->size; ++i) {
    if (!allocation_matches(expected->buffer[i], actual->buffer[i])) {
      return 0;
    }
  }

  return 1;
}

int compute_allocations_tests([[maybe_unused]] int argc,
                              [[maybe_unused]] char **argv) {

  Lifetimes test       = test_lifetimes();
  Allocations expected = expected_allocations();

  Allocations actual = compute_allocations(&test);

  bool failure = !allocations_match(&expected, &actual);

  lifetimes_destroy(&test);
  allocations_destroy(&expected);
  allocations_destroy(&actual);
  if (failure) {
    return EXIT_FAILURE;
  } else {
    return EXIT_SUCCESS;
  }
}